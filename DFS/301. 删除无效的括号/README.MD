删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。

说明: 输入可能包含了除 ( 和 ) 以外的字符。

示例 1:

输入: "()())()"
输出: ["()()()", "(())()"]
示例 2:

输入: "(a)())()"
输出: ["(a)()()", "(a())()"]
示例 3:

输入: ")("
输出: [""]

这道题是DFS和贪心法结合的一道题。
首先求出最少移除几个字符可以满足合法字符串的条件ret_len，然后计算出最终合法字符串的长度n-ret_len.

接下来就是用DFS来遍历所有的路线，每一个字符都可以取或者不取，所以一共的time complexity是O(2^n).这个操作并不会超时，但是最终是要输出没有重复的字符串组合，所以如何剪枝或者去重就是保证时间复杂度在规定范围内的关键。

楼主教的去重方法是如果当前index的字符和已选字符串的最后一位不相同，那么在当前DFS层具有选择当前字符和不选当前字符的权利

如果当前index的字符和已选字符串的最后一位相同，那么当前DFS只具有选择权，没有不选择权。

比如有如下字符

B AAAA

如果我们要选两个A，那么如果我们不规定这个限制，那么就有如下宣发

B AA 
B A A
B A  A
B  AA 
B  A A 
B   AA

空位代表了我们没有选择哪个A

如果有限制，那么我们的选择为

B   AA

只有最后两个AA会被选择。

需要注意的是这个方法一定要递归到最后一层，也就是index==n的那个时候，这个时候才是我们判断当前字符串是否合法，也就是说这个方法不能提前剪枝。

比如如果是

B AAAA

这种字符串在拿到两个A的时候就return，就会导致重复，最后还需要用hashset来去重。所以一定要注意。