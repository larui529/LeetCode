这是一道第一类DP题，就是这个状态下的结果只和上一个时间节点的状态有关， 也就是dp[i]可以用dp[i-1]推导得出。 因为每一个时间节点都有很多状态，所以要用一个二维数组来记录每个时间节点的状态和结果。

首先我们要找的是状态转移方程，假设dp[i][state(j)]表示的是在转到第i个字母时同时是第state（j)这个状态，状态表示的是某一种字母排列，比如我们用第一个字母表示在12点方向上的字母，那么“godding”和“ggoddin”虽然12点方向都是g，但他们是两个状态。假如现在我们要求12点方向是d同时状态是“godding"这种组合，那么我们要遍历的就是在上一个时间点dp[i-1]所有的i-1时间点上可能的字母组合中转到现在状态的最小值，也就是

dp[i][state(i)] = min(dp[i-1][state(i-1)])

要注意的是我们可以正反方向转，所以要看两个方向哪个走的路更短。

在dp的部分之前我们要先建立每个12点字母对应的状态

[LeetCode Link](https://leetcode-cn.com/problems/freedom-trail/)