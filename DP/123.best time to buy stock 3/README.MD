给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

我一开始的想法是分四种状态， sell, buy, hold, nothold
hold就是当天没买但持有，nothold就是当天没卖但不持有
后来看了群主的视频发信只需要两个状态就可以， sold和hold,hold表示有股票，可以是当天买的也可以是以前买的，sold表示当天没股票，可以是当天卖的也可以是以前卖的，
而因为我们只能进行两次交易，所以有hold1, hold2,和sold1, sold2四种状态
所以我用了四个 dp list来记录这些状态。状态转移方程如下

sold1[i] = max(sold1[i-1], hold1[i-1]+prices[i])
sold2[i] = max(sold2[i-1], hold2[i-1]+prices[i])
hold1[i] = max(0-prices[i], hold1[i-1])
hold2[i] = max(sold1[i-1]-prices[i], hold2[i-1])

然后我们需要考虑initial的值也就是第0天使的sold1, sold2, hold1, hold2

我们可以通过第一天我们希望各个dp怎么选来决定

sold1[0], sold2[0]都是0，因为我们没有做任何的交易，所以我们没有profit
hold1[0], hold2[0]我们要设为负无穷，因为在sold1[1]中我们有两个选项，sold1[0], hold1[0]+prices[1],如果我们不把hold[0]设为负无穷，那么sold[1]就有可能选后边那一项，也就是一个大于零的数字，这是不可能的，因为第一天不可能卖股票，如果没买就卖那不就不劳而获了吗，所以hold1[0]一定不能被选，所以要设为负无穷，同理是sold2[0]