这道题是一道典型的第一类DP题，也就是当前状态只和上一个状态有关，可以看到每一个step和位置（除了第一和最后一个位置）都有三种状态，不动，左移，右移，也就是如果我们定义一个二维dp来表示每个step和每个位置的可以走法，那么最后我们要求的是在最后一步0这个位置一共有多少种走法，也就是dp[-1][0]

但是这个题tricky的部分在于arrLen特别大，如果我们定义一个steps*arrLen的数组并遍历所有可能的值就会超时。

但我们发现最后返回的是在0位置的走法，假如说我们一直想右走，最多走到steps//2就要往回走了，比如steps==100, arrLen大于100时就如我们花50步走到了50这个位置，在第51步时我们有三种位置

dp[51][49] 向左走（1）
dp[51][51] 向右走（2）
dp[51][50] 不动（3）

但第二和第三种状态我们永远都不会回到0位置了。 我们可以想象最后dp[100][0]是怎么得到的

dp[100][0] = dp[99][0] + dp[99][1]

而之前我们在第51步的三个状态只有dp[51][49]会对dp[99][1]有贡献，因为它拼死拼活一直向左走才能走到1，然后最后一步归位到0.所以我们如果不算dp[51][51]和dp[51][50]根本对最后的结果没有影响，那我们就不需要遍历position这个维度上大于steps//2+1后的位置了，所以最后时间复杂度只要O(steps*steps/2)就可以了。

最后说一下边界条件，我们仍然需要一个种子，也就是dp[0][0]，在没有走的时候在0位置有多少种走法呢？是1，因为刚开始没走的时候已经在0位置了，所以是1.

[LeetCode Link](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/) 