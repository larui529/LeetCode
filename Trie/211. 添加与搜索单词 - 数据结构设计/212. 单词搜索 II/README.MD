这个题也是利用trie来进行单词的搜索

首先用words建一个trie

然后来遍历board中的所有字母，如果字母在trie中，那么进入dfs循环，在循环中，我们用回溯来判断这个position是否遍历到过，要用一个visited辅助array来记录这个字母是否被用到。

拿到一个位置，首先判断这个位置是否超过边界，然后看是否visited过，如果‘#’（word结束符）在当前的tree中，说明之前走过的路径是一个可选单词，假如res中，如果当前位置上的字母在tree中，则进入回溯过程，首先在visited上添加这个位置，然后在chosen中添加这个字母，然后遍历四个方向，用新的tree[e]， e为当前字母。遍历结束后要在visited中删掉位置，在chosen删掉字母，结束这个layer的dfs函数，返回

时间复杂度：因为每个位置都要过，所以worst case是每个位置都要进dfs，而在dfs中首字母可以走4个方向，其他延伸出去的位置可以走三个方向（原方向visited），最大的递归层数是最长的单词长度。 所以是O(N*4*(3^L-1))