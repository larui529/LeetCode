这道题主要是让我们在一个有n个num的array里找出有两个重复数字的数

e.g.[4,3,2,7,8,2,3,1]
[2,3] 这两个数出现了两次

这个题的逻辑是把原数组整理然后找和index+1不一样的那些数。

整理后变成[1,2,3,4,2,3,7,8]

我们发现2占了理应是5的位置，3占了理应是6的位置。那么这两个数就是要找的数

那么如何整理呢？

那就需要我们顺序遍历数组，然后看在当前位置上的数字理应坐在的那个位置上是不是这个数。

比如nums[0] = 4, 在index=3的这个位置上应该坐的是4，但现在是7，所以我们把4,7交换，接下来再看在index=6的位置上坐的是不是7呢，也不是，那继续交换。

直到最后找到了1，也就是应该坐在这个位置上的数，停止while loop，接下来如果这个位置上已经坐了该坐的数，那我们就不需要移动了，所以每个数最多只会移动一次，也就是O(N)时间复杂度。

比如说有两个3，最后整理的结果必然是一个3坐到了自己改做的index=2的位置，另一个3必然在缺失了的那个数字的位置，应为其他的位置都有人坐了。

