# 424. 替换后的最长重复字符

问题描述（中文）：给你一个仅由大写英文字母组成的字符串 s 和一个整数 k，你可以选择任意位置的字符并将其替换成另一个大写字符，最多可替换 k 次。返回在替换字符后，包含相同字母的最大子串长度。

解题思路（中文）：
- 使用滑动窗口维护当前窗口长度和窗口内出现次数最多的字符 count_max。窗口长度减去 count_max 即为需要替换的字符数。
- 当所需替换数大于 k 时，缩小左边界。
- 关键点：维护窗口内的字符计数，以及动态更新 count_max（可只在增加字符时更新，窗口缩小时无需立即重算 count_max，仍保持正确性）。
- 时间复杂度：O(n)，空间复杂度：O(26)。

- Rui's idea
 - 这个题和其他的不同在于这个是两个pointer都从左滑，有亮点需要想清楚
  - 1. 首先为什么不是每个i，j都需要比较，因为我们要找最大的窗口，比如现在l在1， r在8，那假如现在l开始动了以后【2，8】，【3，8】会ignore【1，7】，【2，7】这些情况，但这些情况其实是不需要考虑的，因为他们已经包括在1，8这种情况里了
  - 2. 然后就是如何计算max_count，我们不需要总是去output freq.most_common(), 因为max_count只可能是max(max_count, freq[s[r]]), 所以只需要重复计算下边的就可以了
  
    ```
    max_count = max(max_count, freq[s[r]])
            replace_n = r - l +1 - max_count
    ```